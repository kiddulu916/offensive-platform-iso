"""Exploit database lookup for vulnerability matching"""
from typing import Dict, Any, List
import requests
import re
import json
from pathlib import Path

class ExploitLookupProcessor:
    """Processor for looking up exploits from service fingerprints"""

    DANGEROUS_TYPES = {
        'dos', 'denial of service', 'ddos',
        'social engineering', 'phishing', 'spam'
    }

    def __init__(self):
        self.exploitdb_api = "https://www.exploit-db.com/search"
        self.cve_api = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        self.session = requests.Session()

    def execute(self, task, previous_results: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute exploit lookup task

        Args:
            task: WorkflowTask with parameters:
                - source_task: Task containing service fingerprints
                - source_field: Field with service data (default: "services")
                - include_experimental: Include experimental exploits (default: False)
            previous_results: Previous task results

        Returns:
            Dictionary with matched_exploits list
        """
        try:
            params = task.parameters
            source_task = params.get("source_task")
            source_field = params.get("source_field", "services")

            if source_task not in previous_results:
                return {"success": False, "error": "Source task not found"}

            services = previous_results[source_task].get(source_field, [])

            # Look up exploits for each service
            matched_exploits = []

            for service in services:
                service_name = service.get("service") or service.get("name", "")
                version = service.get("version", "")

                if not service_name:
                    continue

                # Query exploit databases
                exploits = self._query_exploits(service_name, version)

                # Filter out dangerous exploit types
                safe_exploits = self._filter_safe_exploits(exploits)

                if safe_exploits:
                    matched_exploits.append({
                        "service": service_name,
                        "version": version,
                        "host": service.get("host", ""),
                        "port": service.get("port", ""),
                        "exploits": safe_exploits
                    })

            return {
                "success": True,
                "matched_exploits": matched_exploits,
                "total_matches": len(matched_exploits)
            }

        except Exception as e:
            return {"success": False, "error": str(e)}

    def _query_exploits(self, service: str, version: str) -> List[Dict]:
        """Query multiple exploit sources"""
        exploits = []

        # Try local ExploitDB cache first
        local_results = self._query_local_exploitdb(service, version)
        exploits.extend(local_results)

        # Try CVE database
        try:
            cve_results = self._query_nvd_cve(service, version)
            exploits.extend(cve_results)
        except Exception:
            pass  # CVE lookup failed, continue

        return exploits

    def _query_local_exploitdb(self, service: str, version: str) -> List[Dict]:
        """Query local ExploitDB cache (if available)"""
        # Check for local exploitdb clone
        exploitdb_path = Path("/usr/share/exploitdb/files_exploits.csv")

        if not exploitdb_path.exists():
            return []

        matches = []
        search_term = f"{service} {version}".lower()

        try:
            with open(exploitdb_path, 'r', encoding='latin1') as f:
                for line in f:
                    if search_term in line.lower():
                        parts = line.split(',')
                        if len(parts) >= 3:
                            matches.append({
                                "id": parts[0],
                                "description": parts[2],
                                "type": parts[1] if len(parts) > 1 else "unknown",
                                "source": "exploitdb"
                            })
        except Exception:
            pass

        return matches[:10]  # Limit results

    def _query_nvd_cve(self, service: str, version: str) -> List[Dict]:
        """Query NVD CVE database"""
        matches = []

        try:
            # Build search query
            keyword = f"{service} {version}"

            params = {
                "keywordSearch": keyword,
                "resultsPerPage": 10
            }

            response = self.session.get(
                self.cve_api,
                params=params,
                timeout=10
            )

            if response.status_code == 200:
                data = response.json()

                for vuln in data.get("vulnerabilities", []):
                    cve = vuln.get("cve", {})

                    matches.append({
                        "id": cve.get("id", ""),
                        "description": cve.get("descriptions", [{}])[0].get("value", ""),
                        "cvss_score": self._extract_cvss(cve),
                        "source": "nvd"
                    })

        except Exception:
            pass  # API request failed

        return matches

    def _extract_cvss(self, cve: Dict) -> float:
        """Extract CVSS score from CVE data"""
        try:
            metrics = cve.get("metrics", {})
            cvss_v3 = metrics.get("cvssMetricV31", [{}])[0]
            return cvss_v3.get("cvssData", {}).get("baseScore", 0.0)
        except Exception:
            return 0.0

    def _parse_service_version(self, service_string: str) -> Dict[str, str]:
        """Parse service and version from string like 'Apache httpd 2.4.49'"""
        # Try to match pattern: "Product Version"
        match = re.search(r'(.+?)\s+([\d.]+)', service_string)

        if match:
            return {
                "product": match.group(1).strip(),
                "version": match.group(2).strip()
            }

        return {"product": service_string, "version": ""}

    def _filter_safe_exploits(self, exploits: List[Dict]) -> List[Dict]:
        """Filter out DoS, social engineering, and other dangerous exploit types"""
        safe = []

        for exploit in exploits:
            exploit_type = exploit.get("type", "").lower()
            description = exploit.get("description", "").lower()

            # Check if exploit type or description contains dangerous keywords
            is_dangerous = any(
                danger in exploit_type or danger in description
                for danger in self.DANGEROUS_TYPES
            )

            if not is_dangerous:
                safe.append(exploit)

        return safe
